<!DOCTYPE html>
<html>
  <head>
    <title>Affine ciphers</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      /* Slideshow styles */
      body {
        font-size: 20px;
      }
      h1, h2, h3 {
        font-weight: 400;
        margin-bottom: 0;
      }
      h1 { font-size: 3em; }
      h2 { font-size: 2em; }
      h3 { font-size: 1.6em; }
      a, a > code {
        text-decoration: none;
      }
      code {
        -moz-border-radius: 5px;
        -web-border-radius: 5px;
        background: #e7e8e2;
        border-radius: 5px;
        font-size: 16px;
      }
      .plaintext {
        background: #272822;
        color: #80ff80;
        text-shadow: 0 0 20px #333;
        padding: 2px 5px;
      }
      .ciphertext {
        background: #272822;
        color: #ff6666;
        text-shadow: 0 0 20px #333;
        padding: 2px 5px;
      }
       .float-right {
        float: right;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

# Affine ciphers

a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z
--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|--
b | e | h | k | n | q | t | w | z | c | f | i | l | o | r | u | x | a | d | g | j | m | p | s | v | y

An extension of Caesar ciphers

* Count the gaps in the letters.

---
# How affine ciphers work

_ciphertext_letter_ =_plaintext_letter_ × a + b

* Convert letters to numbers
* Take the total modulus 26

# Enciphering is easy

* Build the `affine_encipher()` function

---

# Deciphering affine ciphers is harder

`$$p = \frac{c - b}{a} \mod 26$$`

But modular division is hard!

Define division as mutiplication by the inverse: `\(\frac{x}{y} = x \times \frac{1}{y} = x \times y^{-1}\)`

A number _x_, when multiplied by its inverse _x_<sup>-1</sup>, gives result of 1.

This is not always defined in modular arithmetic. For instance, 7 × 4 = 28 = 2 mod 26, but 20 × 4 = 80 = 2 mod 26. Therefore, 4 doesn't have a multiplicative inverse (and therefore makes a bad key for affine ciphers).

Result from number theory: only numbers coprime with _n_ have multiplicative inverses in arithmetic mod _n_.

Another result from number theory: for non-negative integers _a_ and _n_, and there exist unique integers _x_ and _y_ such that _ax_ + _ny_ = gcd(_a_, _b_)

Coprime numbers have gcd of 1.

_ax_ + _ny_ = 1 mod _n_. But _ny_ mod _n_ = 0, so _ax_ = 1 mod _n_, so _a_ = _x_<sup>-1</sup>.

Perhaps the algorithm for finding gcds could be useful?

---

# Euclid's algorithm

World's oldest algorithm.

_a_ = _qb_ + _r_

gcd(_a_, _b_) = gcd(_qb_ + _r_, _b_) = gcd(_r_, _b_) = gcd(_b_, _r_)

Repeatedly apply these steps until _r_ = 0, when the other number = gcd(a,b)

For instance, _a_ = 81, _b_ = 57

* 81 = 1 × 57 + 24
* 57 = 2 × 24 + 9
* 24 = 2 × 9 + 6
* 9 = 1 × 6 + 3
* 6 = 2 × 3 + 0

Therefore, gcd(81, 57) = 3 and 81_x_ + 57_y_ = 3

Now unfold the derivation to find _x_ and _y_

* 3 = 9 × 1 + 6 × -1
* 3 = 9 × 1 + (24 - 2 × 9) × -1 = 9 × 3 + 24 × -1
* 3 = (57 - 2 × 24) × 3 + 24 × -1 = 57 × 3 + 24 × -7
* 3 = 57 × 3 + (81 - 57 × 1) × -7 = 57 × 10 + 81 × -7 

---

# Example above from http://www-math.ucdenver.edu/~wcherowi/courses/m5410/exeucalg.html

## Explanation of extended Euclid's algorithm from [Programming with finite fields](http://jeremykun.com/2014/03/13/programming-with-finite-fields/)

**Definition:** An element _d_ is called a greatest common divisor (gcd) of _a, b_ if it divides both _a_ and _b_, and for every other _z_ dividing both _a_ and _b_, _z_ divides _d_. 

**Theorem:** For any two integers _a, b_ there exist unique integers _x, y_ such that _ax_ + _by_ = gcd(_a, b_).

We could beat around the bush and try to prove these things in various ways, but when it comes down to it there’s one algorithm of central importance that both computes the gcd and produces the needed linear combination _x, y_. The algorithm is called the Euclidean algorithm. Here is a simple version that just gives the gcd.

```python
def gcd(a, b):
   if abs(a) &lt; abs(b):
      return gcd(b, a)
 
   while abs(b) > 0:
      q,r = divmod(a,b)
      a,b = b,r
 
   return a
```

This works by the simple observation that gcd(_a_, _aq_ + _r_) = gcd(_a_, _r_) (this is an easy exercise to prove directly). So the Euclidean algorithm just keeps applying this rule over and over again: take the remainder when dividing the bigger argument by the smaller argument until the remainder becomes zero. Then gcd(_x_, 0) = 0 because everything divides zero.

---

Now the so-called ‘extended’ Euclidean algorithm just keeps track of some additional data as it goes (the partial quotients and remainders). Here’s the algorithm.

```python
def extendedEuclideanAlgorithm(a, b):
   if abs(b) &gt; abs(a):
      (x,y,d) = extendedEuclideanAlgorithm(b, a)
      return (y,x,d)
 
   if abs(b) == 0:
      return (1, 0, a)
 
   x1, x2, y1, y2 = 0, 1, 1, 0
   while abs(b) > 0:
      q, r = divmod(a,b)
      x = x2 - q*x1
      y = y2 - q*y1
      a, b, x2, x1, y2, y1 = b, r, x1, x, y1, y
 
   return (x2, y2, a)
```

Indeed, the reader who hasn’t seen this stuff before is encouraged to trace out a run for the numbers 4864, 3458. Their gcd is 38 and the two integers are 32 and -45, respectively.

How does this help us compute inverses? Well, if we want to find the inverse of _a_ modulo _p_, we know that their gcd is 1. So compute the _x, y_ such that _ax_ + _py_ = 1, and then reduce both sides mod _p_. You get _ax_ + 0 = 1 _mod p_, which means that _x mod p_ is the inverse of _a_. So once we have the extended Euclidean algorithm our inverse function is trivial to write!

```python
def inverse(self):
   x,y,d = extendedEuclideanAlgorithm(self.n, self.p)
   return IntegerModP(x)
```

And indeed it works as expected:

```python
>>> mod23 = IntegersModP(23)
>>> mod23(7).inverse()
10 (mod 23)
>>> mod23(7).inverse() * mod23(7)
1 (mod 23)
```


    </textarea>
    <script src="http://gnab.github.io/remark/downloads/remark-0.6.0.min.js" type="text/javascript">
    </script>

    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&delayStartupUntil=configured"></script>

    <script type="text/javascript">
      var slideshow = remark.create({ ratio: "16:9" });

      // Setup MathJax
      MathJax.Hub.Config({
        tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        }
      });
      MathJax.Hub.Queue(function() {
        $(MathJax.Hub.getAllJax()).map(function(index, elem) {
            return(elem.SourceElement());
        }).parent().addClass('has-jax');
      });
      MathJax.Hub.Configured();
    </script>
  </body>
</html>
